create extension if not exists "pgjwt" with schema "extensions";


create type "public"."task status" as enum ('PENDING', 'SUCCESS', 'ERROR');

create type "public"."task types" as enum ('SET_PASSWD');

create table "public"."computers" (
    "id" bigint generated by default as identity not null,
    "rustdesk_id" numeric not null,
    "name" character varying not null,
    "ip" character varying,
    "last_connection" timestamp without time zone default now(),
    "os" character varying,
    "os_version" character varying,
    "created_at" timestamp with time zone not null default now(),
    "key" uuid not null default gen_random_uuid(),
    "login_user" character varying
);


alter table "public"."computers" enable row level security;

create table "public"."tasks" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "task" "task types",
    "status" "task status" not null,
    "computer_id" bigint
);


alter table "public"."tasks" enable row level security;

CREATE UNIQUE INDEX computers_id_key ON public.computers USING btree (id);

CREATE UNIQUE INDEX computers_key_key ON public.computers USING btree (key);

CREATE UNIQUE INDEX computers_pkey ON public.computers USING btree (id, rustdesk_id);

CREATE UNIQUE INDEX computers_rustdesk_id_key ON public.computers USING btree (rustdesk_id);

CREATE UNIQUE INDEX tasks_pkey ON public.tasks USING btree (id);

alter table "public"."computers" add constraint "computers_pkey" PRIMARY KEY using index "computers_pkey";

alter table "public"."tasks" add constraint "tasks_pkey" PRIMARY KEY using index "tasks_pkey";

alter table "public"."computers" add constraint "computers_id_key" UNIQUE using index "computers_id_key";

alter table "public"."computers" add constraint "computers_key_key" UNIQUE using index "computers_key_key";

alter table "public"."computers" add constraint "computers_rustdesk_id_key" UNIQUE using index "computers_rustdesk_id_key";

alter table "public"."tasks" add constraint "tasks_computer_id_fkey" FOREIGN KEY (computer_id) REFERENCES computers(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."tasks" validate constraint "tasks_computer_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_computer_by_key(in_rustdesk_id numeric, in_key uuid)
 RETURNS record
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
SELECT *
FROM public.computers
WHERE computers.rustdesk_id = $1 AND computers.key = $2;
$function$
;

CREATE OR REPLACE FUNCTION public.get_tasks_by_rustdesk_id(in_rustdesk_id integer, in_key uuid)
 RETURNS record
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$SELECT public.tasks.created_at, public.tasks.status, public.tasks.task

FROM public.tasks

INNER JOIN public.computers ON public.computers.id = public.tasks.id

WHERE public.computers.rustdesk_id = $1 AND public.computers.key = $2;$function$
;

CREATE OR REPLACE FUNCTION public.is_computer_registered(in_rustdesk_id integer)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$SELECT EXISTS (

    SELECT 1 

    FROM public.computers 

    WHERE computers.rustdesk_id = $1

) AS exists_result;$function$
;

CREATE OR REPLACE FUNCTION public.register_computer(in_name character varying, in_rustdesk_id integer, in_key uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$WITH ins AS (
  INSERT INTO public.computers (name, rustdesk_id, key)
  VALUES ($1, $2, $3)
  RETURNING 1       
)
SELECT EXISTS (SELECT 1 FROM ins) AS success;$function$
;

CREATE OR REPLACE FUNCTION public.update_computer(in_name character varying, in_rustdesk_id integer, in_key uuid, in_ip character varying, in_os character varying, in_os_version character varying, in_login_user character varying, in_last_connection timestamp without time zone)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$WITH ins AS (
  UPDATE public.computers SET 
    name = in_name,
    ip = in_ip,
    os = in_os,
    os_version = in_os_version,
    login_user = in_login_user,
    last_connection = in_last_connection
  WHERE
    rustdesk_id = in_rustdesk_id
    AND key = in_key
  RETURNING 1 
)
SELECT EXISTS (SELECT 1 FROM ins) AS success;$function$
;

grant delete on table "public"."computers" to "anon";

grant insert on table "public"."computers" to "anon";

grant references on table "public"."computers" to "anon";

grant select on table "public"."computers" to "anon";

grant trigger on table "public"."computers" to "anon";

grant truncate on table "public"."computers" to "anon";

grant update on table "public"."computers" to "anon";

grant delete on table "public"."computers" to "authenticated";

grant insert on table "public"."computers" to "authenticated";

grant references on table "public"."computers" to "authenticated";

grant select on table "public"."computers" to "authenticated";

grant trigger on table "public"."computers" to "authenticated";

grant truncate on table "public"."computers" to "authenticated";

grant update on table "public"."computers" to "authenticated";

grant delete on table "public"."computers" to "postgres";

grant insert on table "public"."computers" to "postgres";

grant references on table "public"."computers" to "postgres";

grant select on table "public"."computers" to "postgres";

grant trigger on table "public"."computers" to "postgres";

grant truncate on table "public"."computers" to "postgres";

grant update on table "public"."computers" to "postgres";

grant delete on table "public"."computers" to "service_role";

grant insert on table "public"."computers" to "service_role";

grant references on table "public"."computers" to "service_role";

grant select on table "public"."computers" to "service_role";

grant trigger on table "public"."computers" to "service_role";

grant truncate on table "public"."computers" to "service_role";

grant update on table "public"."computers" to "service_role";

grant delete on table "public"."tasks" to "anon";

grant insert on table "public"."tasks" to "anon";

grant references on table "public"."tasks" to "anon";

grant select on table "public"."tasks" to "anon";

grant trigger on table "public"."tasks" to "anon";

grant truncate on table "public"."tasks" to "anon";

grant update on table "public"."tasks" to "anon";

grant delete on table "public"."tasks" to "authenticated";

grant insert on table "public"."tasks" to "authenticated";

grant references on table "public"."tasks" to "authenticated";

grant select on table "public"."tasks" to "authenticated";

grant trigger on table "public"."tasks" to "authenticated";

grant truncate on table "public"."tasks" to "authenticated";

grant update on table "public"."tasks" to "authenticated";

grant delete on table "public"."tasks" to "postgres";

grant insert on table "public"."tasks" to "postgres";

grant references on table "public"."tasks" to "postgres";

grant select on table "public"."tasks" to "postgres";

grant trigger on table "public"."tasks" to "postgres";

grant truncate on table "public"."tasks" to "postgres";

grant update on table "public"."tasks" to "postgres";

grant delete on table "public"."tasks" to "service_role";

grant insert on table "public"."tasks" to "service_role";

grant references on table "public"."tasks" to "service_role";

grant select on table "public"."tasks" to "service_role";

grant trigger on table "public"."tasks" to "service_role";

grant truncate on table "public"."tasks" to "service_role";

grant update on table "public"."tasks" to "service_role";

create policy "Enable read access for all authenticated"
on "public"."computers"
as permissive
for select
to authenticated
using (true);


create policy "Enable select for authenticated"
on "public"."tasks"
as permissive
for select
to authenticated
using (true);

